<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.blocktalk.top","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Stream:Internet Engineering Task Force (IETF)RFC:8765Category:Standards Track Published:June 2020ISSN:2070-1721Authors: T. Pusateri Una�liated S. Cheshire Apple Inc. Rfc 8765 Dns Push Notifications Ab">
<meta property="og:type" content="article">
<meta property="og:title" content="BlockTalk">
<meta property="og:url" content="http://blog.blocktalk.top/2023/12/11/2023/rfc8765_2/index.html">
<meta property="og:site_name" content="BlockTalk">
<meta property="og:description" content="Stream:Internet Engineering Task Force (IETF)RFC:8765Category:Standards Track Published:June 2020ISSN:2070-1721Authors: T. Pusateri Una�liated S. Cheshire Apple Inc. Rfc 8765 Dns Push Notifications Ab">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-12-11T07:58:16.301Z">
<meta property="article:modified_time" content="2023-12-11T08:02:13.767Z">
<meta property="article:author" content="jason">
<meta property="article:tag" content="书 电子数 epub mobi pdf">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://blog.blocktalk.top/2023/12/11/2023/rfc8765_2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><style>
#needsharebutton-postbottom {
  cursor: pointer;
  height: 26px;
  margin-top: 10px;
  position: relative;
}
#needsharebutton-postbottom .btn {
  border: 1px solid $btn-default-border-color;
  border-radius: 3px;
  display: initial;
  padding: 1px 4px;
}
</style>
  <title> | BlockTalk</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">

<div style="display:none;"><img src="/img/test.jpeg" alt=""></div>
<meta property="og:image" content="/img/test.jpeg">

  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">BlockTalk</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.blocktalk.top/2023/12/11/2023/rfc8765_2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jason">
      <meta itemprop="description" content="唯有读书最快乐">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BlockTalk">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-12-11 15:58:16 / 修改时间：16:02:13" itemprop="dateCreated datePublished" datetime="2023-12-11T15:58:16+08:00">2023-12-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Stream:<br>Internet Engineering Task Force (IETF)<br>RFC:<br>8765<br>Category:<br>Standards Track Published:<br>June 2020<br>ISSN:<br>2070-1721<br>Authors:</p>
<p>T. Pusateri Una�liated S. Cheshire Apple Inc.</p>
<h2 id="Rfc-8765-Dns-Push-Notifications-Abstract"><a href="#Rfc-8765-Dns-Push-Notifications-Abstract" class="headerlink" title="Rfc 8765 Dns Push Notifications Abstract"></a>Rfc 8765 Dns Push Notifications Abstract</h2><p>The Domain Name System (DNS) was designed to return matching records efficiently for queries for data that are relatively static. When those records change frequently, DNS is still efficient at returning the updated results when polled, as long as the polling rate is not too high. But, there exists no mechanism for a client to be asynchronously notified when these changes occur. This document defines a mechanism for a client to be notified of such changes to DNS records, called DNS Push Notifications.</p>
<h2 id="Status-Of-This-Memo"><a href="#Status-Of-This-Memo" class="headerlink" title="Status Of This Memo"></a>Status Of This Memo</h2><p>This is an Internet Standards Track document. This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841. Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at<br>.</p>
<p><a target="_blank" rel="noopener" href="https://www.rfc-editor.org/info/rfc8765">https://www.rfc-editor.org/info/rfc8765</a></p>
<h2 id="Copyright-Notice"><a href="#Copyright-Notice" class="headerlink" title="Copyright Notice"></a>Copyright Notice</h2><p>Copyright (c) 2020 IETF Trust and the persons identified as the document authors. All rights reserved.</p>
<p><a target="_blank" rel="noopener" href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a> This document is subject to BCP 78 and the IETF Trust’s Legal Provisions Relating to IETF Documents (<br>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>
<h2 id="Table-Of-Contents"><a href="#Table-Of-Contents" class="headerlink" title="Table Of Contents"></a>Table Of Contents</h2><ol>
<li> Introduction</li>
<li><ol>
<li> Requirements Language</li>
</ol>
</li>
<li><ol start="2">
<li> Fatal Errors</li>
</ol>
</li>
<li> Motivation 3.  Overview 4.  State Considerations 5.  Transport</li>
<li> Protocol Operation</li>
<li><ol>
<li> Discovery</li>
</ol>
</li>
<li><ol start="2">
<li> DNS Push Notification SUBSCRIBE</li>
</ol>
</li>
<li>2.1.  SUBSCRIBE Request</li>
<li>2.2.  SUBSCRIBE Response</li>
<li><ol start="3">
<li> DNS Push Notification Updates</li>
</ol>
</li>
<li>3.1.  PUSH Message</li>
<li><ol start="4">
<li> DNS Push Notification UNSUBSCRIBE</li>
</ol>
</li>
<li>4.1.  UNSUBSCRIBE Message</li>
<li><ol start="5">
<li> DNS Push Notification RECONFIRM</li>
</ol>
</li>
<li>5.1.  RECONFIRM Message</li>
<li><ol start="6">
<li> DNS Stateful Operations TLV Context Summary 6.7.  Client-Initiated Termination 6.8.  Client Fallback to Polling</li>
</ol>
</li>
<li> Security Considerations</li>
<li><ol>
<li> Security Services</li>
</ol>
</li>
<li><ol start="2">
<li> TLS Name Authentication 7.3.  TLS Early Data 7.4.  TLS Session Resumption</li>
</ol>
</li>
<li> IANA Considerations 9.  References</li>
<li><ol>
<li> Normative References</li>
</ol>
</li>
<li><ol start="2">
<li> Informative References<br>Acknowledgments Authors’ Addresses</li>
</ol>
</li>
</ol>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>[RFC2136]<br>[RFC8766]<br>[RFC6763]<br>Domain Name System (DNS) records may be updated using DNS Update<br>. Other mechanisms such as a Discovery Proxy can also generate changes to a DNS zone. This document specifies a protocol for DNS clients to subscribe to receive asynchronous notifications of changes to RRsets of interest. It is immediately relevant in the case of DNS-based Service Discovery but is not limited to that use case; it provides a general DNS mechanism for DNS record change notifications. Familiarity with the DNS protocol and DNS packet formats is assumed </p>
<p>.</p>
<p>[RFC1034] [RFC1035] [RFC6895]</p>
<h2 id="1-1-Requirements-Language"><a href="#1-1-Requirements-Language" class="headerlink" title="1.1. Requirements Language"></a>1.1. Requirements Language</h2><p>MUST<br>      MUST NOT<br>               REQUIRED<br>                        SHALL<br>                               SHALL NOT<br>                                         SHOULD<br>                                                 SHOULD</p>
<p>NOT<br>     RECOMMENDED<br>                  NOT RECOMMENDED<br>                                   MAY<br>                                           OPTIONAL<br>                           [RFC2119] [RFC8174]</p>
<p>The key words “<br>                    “, “<br>                                “, “<br>                                            “, “<br>                                                     “, “<br>                                                                  “, “<br>                                                                            “, “<br>   “, “<br>                     “, “<br>                                           “, “<br>                                                 “, and “<br>                                                                  “ in this document are to<br>be interpreted as described in BCP 14 </p>
<pre><code>                                                    when, and only when, they appear in
</code></pre>
<p>all capitals, as shown here.</p>
<h2 id="1-2-Fatal-Errors"><a href="#1-2-Fatal-Errors" class="headerlink" title="1.2. Fatal Errors"></a>1.2. Fatal Errors</h2><p>Certain invalid situations are described in this specification, such as a server sending a Push Notification subscription request to a client, or a client sending a Push Notification response to a server. These should never occur with a correctly implemented client and server, and if they do occur, then they indicate a serious implementation error. In these extreme cases, there is no reasonable expectation of a graceful recovery, and the recipient detecting the error should respond by unilaterally aborting the session without regard for data loss. Such cases are addressed by having an engineer investigate the cause of the failure and fixing the problem in the software. Where this specification says “forcibly abort”, it means sending a TCP RST to terminate the TCP connection and the TLS session running over that TCP connection. In the BSD Sockets API, this is achieved by setting the SO_LINGER option to zero before closing the socket.</p>
<h2 id="2-Motivation"><a href="#2-Motivation" class="headerlink" title="2. Motivation"></a>2. Motivation</h2><p>[OBS]<br>[XEP0060]<br>[RFC4287]<br>As the domain name system continues to adapt to new uses and changes in deployment, polling has the potential to burden DNS servers at many levels throughout the network. Other network protocols have successfully deployed a publish/subscribe model following the Observer design pattern<br>. Extensible Messaging and Presence Protocol (XMPP) Publish-Subscribe and Atom are examples. While DNS servers are generally highly tuned and capable of a high rate of query/response traffic, adding a publish/subscribe model for tracking changes to DNS records can deliver more timely notifications of changes with reduced CPU usage and lower network traffic.</p>
<p>[RFC1034]<br>The guiding design principle of DNS Push Notifications is that clients that choose to use DNS Push Notifications, instead of repeated polling with DNS queries, will receive the same results as they could via sufficiently rapid polling, except more efficiently. This means that the rules for which records match a given DNS Push Notification subscription are the same as the already established rules used to determine which records match a given DNS query<br>. For example, name comparisons are done in a case-insensitive manner, and a record of type CNAME in a zone matches any DNS TYPE in a query or subscription.</p>
<p>[RFC6762]<br>[RFC6763]<br>[RFC8766]<br>Multicast DNS<br> implementations always listen on a well-known link-local IP multicast group address, and changes are sent to that multicast group address for all group members to receive. Therefore, Multicast DNS already has asynchronous change notification capability. When DNS-based Service Discovery is used across a wide area network using Unicast DNS (possibly facilitated via a Discovery Proxy<br>), it would be beneficial to have an equivalent capability for Unicast DNS in order to allow clients to learn about DNS record changes in a timely manner without polling.</p>
<p>[RFC8764]<br>[RFC6281]<br>The DNS Long-Lived Queries (LLQ) mechanism is an existing deployed solution to provide asynchronous change notifications; it was used by Apple’s Back to My Mac service introduced in Mac OS X 10.5 Leopard in 2007. Back to My Mac was designed in an era when the data center operations staff asserted that it was impossible for a server to handle large numbers of TCP connections, even if those connections carried very little traffic and spent most of their time idle. Consequently, LLQ was defined as a UDP-based protocol, effectively replicating much of TCP’s connection state management logic in user space and creating its own imitation of existing TCP features like flow control, reliability, and the three-way handshake.</p>
<p>[RFC8490]<br>This document builds on experience gained with the LLQ protocol, with an improved design. Instead of using UDP, this specification uses DNS Stateful Operations (DSO)<br> running over TLS over TCP, and therefore doesn’t need to reinvent existing TCP functionality. Using TCP also gives long-lived low-traffic connections better longevity through NAT gateways without depending on the gateway to support NAT Port Mapping Protocol (NAT-PMP)<br> or Port Control Protocol (PCP)<br>, or resorting to excessive keepalive traffic.</p>
<p>[RFC6886]<br>[RFC6887]</p>
<h2 id="3-Overview"><a href="#3-Overview" class="headerlink" title="3. Overview"></a>3. Overview</h2><p>A DNS Push Notification client subscribes for Push Notifications for a particular RRset by connecting to the appropriate Push Notification server for that RRset and sending DSO message (s) indicating the RRset(s) of interest. When the client loses interest in receiving further updates to these records, it unsubscribes. The DNS Push Notification server for a DNS zone is any server capable of generating the correct change notifications for a name. It may be a primary, secondary, or stealth name server<br>.</p>
<p>[RFC8499]<br>MAY<br>MAY<br>OPTIONAL<br>The _dns‑push‑tls._tcp.<zone> SRV record for a zone reference the same target host and port as that zone’s _dns‑update‑tls._tcp.<zone> SRV record. When the same target host and port is offered for both DNS Updates and DNS Push Notifications, a client use a single DSO<br>session to that server for both DNS Updates and DNS Push Notification subscriptions. DNS Updates and DNS Push Notifications may be handled on different ports on the same target host, in which case they are not considered to be the “same server” for the purposes of this specification, and communications with these two ports are handled independently. Supporting DNS Updates and DNS Push Notifications on the same server is<br>. A DNS Push Notification server is not required to support DNS Update.</p>
<p>MAY<br>MUST<br>MUST<br>Standard DNS Queries be sent over a DNS Push Notification (i.e., DSO) session. For any zone for which the server is authoritative, it respond authoritatively for queries for names falling within that zone (e.g., the _dns‑push‑tls._tcp.<zone> SRV record) both for normal DNS<br>queries and for DNS Push Notification subscriptions. For names for which the server is acting as a recursive resolver (e.g., when the server is the local recursive resolver) for any query for which it supports DNS Push Notification subscriptions, it also support standard queries.</p>
<p>MUST NOT<br>DNS Push Notifications impose less load on the responding server than rapid polling would, but Push Notifications do still have a cost. Therefore, DNS Push Notification clients recklessly create an excessive number of Push Notification subscriptions. Specifically:</p>
<p>(a)<br>A subscription should only be active when there is a valid reason to need live data (for example, an on-screen display is currently showing the results to the user), and the subscription<br> be canceled as soon as the need for that data ends (for example,<br>when the user dismisses that display). In the case of a device like a smartphone that, after some period of inactivity, goes to sleep or otherwise darkens its screen, it should cancel its subscriptions when darkening the screen (since the user cannot see any changes on the display anyway) and reinstate its subscriptions when reawakening from display sleep.<br>SHOULD NOT<br>(b)<br>A DNS Push Notification client<br> routinely keep a DNS Push Notification<br>subscription active 24 hours a day, 7 days a week, just to keep a list in memory up to date so that if the user does choose to bring up an on-screen display of that data, it can be displayed really fast. DNS Push Notifications are designed to be fast enough that there is no need to pre-load a “warm” list in memory just in case it might be needed later.<br>[RFC8490]<br>Generally, as described in the DNS Stateful Operations specification<br>, a client must not keep a DSO session to a server open indefinitely if it has no subscriptions (or other operations) active on that session. A client should begin closing a DSO session immediately after it becomes idle, and then, if needed in the future, open a new session when required. Alternatively, a client may speculatively keep an idle DSO session open for some time, subject to the constraint that it must not keep a session open that has been idle for more than the session’s idle timeout (15 seconds by default)<br>.</p>
<p>[RFC8490]<br>Note that a DSO session that has an active DNS Push Notification subscription is not considered idle, even if there is no traffic flowing for an extended period of time. In this case, the DSO inactivity timeout does not apply, because the session is not inactive, but the keepalive interval does still apply, to ensure the generation of sufficient messages to maintain state in middleboxes (such at NAT gateways or firewalls) and for the client and server to periodically verify that they still have connectivity to each other. This is described in<br>.</p>
<p>Section 6.2 of the DSO specification<br>[RFC8490]</p>
<h2 id="4-State-Considerations"><a href="#4-State-Considerations" class="headerlink" title="4. State Considerations"></a>4. State Considerations</h2><p>Each DNS Push Notification server is capable of handling some finite number of Push Notification subscriptions. This number will vary from server to server and is based on physical machine characteristics, network capacity, and operating system resource allocation. After a client establishes a session to a DNS server, each subscription is individually accepted or rejected. Servers may employ various techniques to limit subscriptions to a manageable level. Correspondingly, the client is free to establish simultaneous sessions to alternate DNS servers that support DNS Push Notifications for the zone and distribute subscriptions at the client’s discretion. In this way, both clients and servers can react to resource constraints.</p>
<h2 id="5-Transport"><a href="#5-Transport" class="headerlink" title="5. Transport"></a>5. Transport</h2><p>[RFC2136] MAY<br>[RFC0768]<br>[RFC0793]<br>Other DNS operations like DNS Update </p>
<p> use either DNS over User Datagram Protocol (UDP)<br> or DNS over Transmission Control Protocol (TCP)<br> as the transport protocol, provided they follow the historical precedent that DNS queries must first be sent using DNS over UDP and only switch to DNS over TCP if needed<br>. This requirement to prefer UDP has subsequently been relaxed<br>.</p>
<p>[RFC1123]<br>[RFC7766]<br>In keeping with the more recent precedent, DNS Push Notification is defined only for TCP. DNS Push Notification clients use DNS Stateful Operations running over TLS over TCP<br>.</p>
<p>MUST<br>[RFC8490]<br>[RFC7858] Connection setup over TCP ensures return reachability and alleviates concerns of state overload at the server, a potential problem with connectionless protocols, which can be more vulnerable to being exploited by attackers using spoofed source addresses. All subscribers are guaranteed to be reachable by the server by virtue of the TCP three-way handshake. Flooding attacks are possible with any protocol, and a benefit of TCP is that there are already established industry best practices to guard against SYN flooding and similar attacks </p>
<p>.</p>
<p>[SYN] [RFC4953]<br>Use of TCP also allows DNS Push Notifications to take advantage of current and future developments in TCP such as Multipath TCP (MPTCP)<br>, TCP Fast Open (TFO)<br>, the TCP RACK fast loss detection algorithm<br>, and so on.</p>
<p>[RFC8684]<br>[RFC7413]<br>[TCPRACK]<br>[RFC8446]</p>
<h2 id="Required"><a href="#Required" class="headerlink" title="Required"></a>Required</h2><p>Transport Layer Security (TLS)<br> is well understood and is used by many applicationlayer protocols running over TCP. TLS is designed to prevent eavesdropping, tampering, and message forgery. TLS is for every connection between a client subscriber and server in this protocol specification. Additional security measures such as client authentication during TLS negotiation may also be employed to increase the trust relationship between client and server.</p>
<h2 id="6-Protocol-Operation"><a href="#6-Protocol-Operation" class="headerlink" title="6. Protocol Operation"></a>6. Protocol Operation</h2><p>The DNS Push Notification protocol is a session-oriented protocol and makes use of DNS Stateful Operations (DSO)<br>.</p>
<p>[RFC8490]<br>For details of the DSO message format, refer to the DNS Stateful Operations specification<br>. Those details are not repeated here.</p>
<p>[RFC8490]<br>MUST<br>DNS Push Notification clients and servers support DSO. A single server can support DNS<br>Queries, DNS Updates, and DNS Push Notifications (using DSO) on the same TCP port. A DNS Push Notification exchange begins with the client discovering the appropriate server, using the procedure described in Section 6.1, and then making a TLS/TCP connection to it.</p>
<p>MAY<br>After making the TLS/TCP connection to the server, a typical DNS Push Notification client will then immediately issue a DSO Keepalive operation to establish the DSO session and request a session timeout and/or keepalive interval longer than the 15-second default values, but this is not required. A DNS Push Notification client issue other requests on the session first, and only issue a DSO Keepalive operation later if it determines that to be necessary. Sending either a DSO Keepalive operation or a Push Notification subscription request over the TLS/TCP connection to the server signals the client’s support of DSO and serves to establish a DSO session.</p>
<p>MUST<br>In accordance with the current set of active subscriptions, the server sends relevant asynchronous Push Notifications to the client. Note that a client be prepared to receive<br>(and silently ignore) Push Notifications for subscriptions it has previously removed, since there is no way to prevent the situation where a Push Notification is in flight from server to client while the client’s UNSUBSCRIBE message canceling that subscription is simultaneously in flight from client to server.</p>
<h2 id="6-1-Discovery"><a href="#6-1-Discovery" class="headerlink" title="6.1. Discovery"></a>6.1. Discovery</h2><p>The first step in establishing a DNS Push Notification subscription is to discover an appropriate DNS server that supports DNS Push Notifications for the desired zone. The client begins by opening a DSO session to its normal configured DNS recursive resolver and requesting a Push Notification subscription. This connection is made to TCP port 853, the default port for DNS over TLS<br>. If the request for a Push Notification subscription is successful,<br>[RFC7858]<br>and the recursive resolver doesn’t already have an active subscription for that name, type, and class, then the recursive resolver will make a corresponding Push Notification subscription on the client’s behalf. Results received are relayed to the client. This is closely analogous to how a client sends a normal DNS query to its configured DNS recursive resolver, which, if it doesn’t already have appropriate answer(s) in its cache, issues an upstream query to satisfy the request.</p>
<p>[RFC8499]<br>In many contexts, the recursive resolver will be able to handle Push Notifications for all names that the client may need to follow. Use of VPN tunnels and Private DNS<br> can create some additional complexity in the client software here; the techniques to handle VPN tunnels and Private DNS for DNS Push Notifications are the same as those already used to handle this for normal DNS queries. If the recursive resolver does not support DNS over TLS, or supports DNS over TLS but is not listening on TCP port 853, or supports DNS over TLS on TCP port 853 but does not support DSO on that port, then the DSO session establishment will fail<br>.</p>
<p>[RFC8490]<br>If the recursive resolver does support DSO on TCP port 853 but does not support Push Notification subscriptions, then when the client attempts to create a subscription, the server will return the DSO error code DSOTYPENI (11). In some cases, the recursive resolver may support DSO and Push Notification subscriptions but may not be able to subscribe for Push Notifications for a particular name. In this case, the recursive resolver should return SERVFAIL to the client. This includes being unable to establish a connection to the zone’s DNS Push Notification server or establishing a connection but receiving a non-success response code. In some cases, where the client has a pre-established trust relationship with the owner of the zone (that is not handled via the usual mechanisms for VPN software), the client may handle these failures by contacting the zone’s DNS Push Notification server directly.</p>
<p>MUST<br>In any of the cases described above where the client fails to establish a DNS Push Notification subscription via its configured recursive resolver, the client should proceed to discover the appropriate server for direct communication. The client also determine on which TCP port the server is listening for connections, which need not be, and often is not, TCP port 53<br>(traditionally used for conventional DNS) or TCP port 853 (traditionally used for DNS over TLS).</p>
<p>The discovery algorithm described here is an iterative algorithm, which starts with the full name of the record to which the client wishes to subscribe. Successive SOA queries are then issued, trimming one label each time, until the closest enclosing authoritative server is discovered. There is also an optimization to enable the client to take a “short cut” directly to the SOA record of the closest enclosing authoritative server in many cases.</p>
<ol>
<li>[RFC1035]<br>[RFC8010] [RFC8011] The client begins the discovery by sending a DNS query to its local resolver, with record type SOA<br>for the record name to which it wishes to subscribe. As an example, suppose<br>the client wishes to subscribe to PTR records with the name _ipp._tcp.headoffice.example.com (to discover Internet Printing Protocol (IPP) printers </li>
</ol>
<p> being advertised in the head office of Example Company). The client<br>begins by sending an SOA query for _ipp._tcp.headoffice.example.com to the local<br>recursive resolver. The goal is to determine the server that is authoritative for the name _ipp._tcp.headoffice.example.com. The closest enclosing DNS zone containing the name _ipp._tcp.headoffice.example.com could be example.com, or headoffice.example.com, or _tcp.headoffice.example.com, or even _ipp._tcp.headoffice.example.com. The client does not know in advance where the closest enclosing zone cut occurs, which is why it uses the iterative procedure described here to discover this information. </p>
<ol start="2">
<li>If the requested SOA record exists, it will be returned in the Answer Section with a NOERROR response code, and the client has succeeded in discovering the information it needs.<br>(This language is not placing any new requirements on DNS recursive resolvers. This text merely describes the existing operation of the DNS protocol </li>
</ol>
<p>.)<br>[RFC1034] [RFC1035]</p>
<ol start="3">
<li><p>If the requested SOA record does not exist, the client will get back a NOERROR/NODATA response or an NXDOMAIN/Name Error response. In either case, the local resolver would<br>normally include the SOA record for the closest enclosing zone of the requested name in the Authority Section. If the SOA record is received in the Authority Section, then the client has succeeded in discovering the information it needs.<br>(This language is not placing any new requirements on DNS recursive resolvers. This text merely describes the existing operation of the DNS protocol regarding negative responses<br>.)<br>[RFC2308]</p>
</li>
<li><p>If the client receives a response containing no SOA record, then it proceeds with the iterative approach. The client strips the leading label from the current query name, and if the resulting name has at least two labels in it, then the client sends an SOA query for that new name and processing continues at step 2 above, repeating the iterative search until either an SOA is received or the query name consists of a single label, i.e., a Top-Level Domain (TLD). In the case of a single-label name (TLD), this is a network configuration error, which should not happen, and the client gives up. The client may retry the operation at a later time of the client’s choosing, such as after a change in network attachment. </p>
</li>
<li><p>[RFC2782]<br>Once the SOA is known (by virtue of being seen either in the Answer Section or in the Authority Section), the client sends a DNS query with type SRV<br>for the record<br>name _dns‑push‑tls._tcp.<zone>, where <zone> is the owner name of the discovered SOA record. </p>
</li>
<li><p>MUST<br>MAY<br>SHOULD<br>If the zone in question is set up to offer DNS Push Notifications, then this SRV record exist. (If this SRV record does not exist, then the zone is not correctly configured for DNS Push Notifications as specified in this document.) The SRV target contains the name of the server providing DNS Push Notifications for the zone. The port number on which to contact the server is in the SRV record port field. The address(es) of the target host<br>be included<br>in the Additional Section, however, the address records<br>be authenticated before use<br>as described in Section 7.2 and in the specification for using DNS-Based Authentication of Named Entities (DANE) TLSA Records with SRV Records<br>, if applicable.<br>[RFC7673]</p>
</li>
<li><p>[RFC2782]<br>More than one SRV record may be returned. In this case, the priority and weight values in<br>the returned SRV records are used to determine the order in which to contact the servers for subscription requests. As described in the SRV specification<br>, the server with the<br>lowest priority is first contacted. If more than one server has the same priority, the<br>weight indicates the weighted probability that the client should contact that server. Higher weights have higher probabilities of being selected. If a server is not willing to accept a subscription request, or is not reachable within a reasonable time, as determined by the client, then a subsequent server is to be contacted. </p>
</li>
</ol>
<p>SHOULD<br>SHOULD<br>MUST<br>Each time a client makes a new DNS Push Notification subscription, it repeat the discovery process in order to determine the preferred DNS server for that subscription at that time. If a client already has a DSO session with that DNS server, the client reuse that existing DSO session for the new subscription; otherwise, a new DSO session is established. The client respect the DNS TTL values on records it receives while performing the discovery process and store them in its local cache with this lifetime (as it will generally do anyway for all DNS queries it performs). This means that, as long as the DNS TTL values on the authoritative records are set to reasonable values, repeated application of the discovery process can be completed practically instantaneously by the client, using only locally stored cached data.</p>
<h2 id="6-2-Dns-Push-Notification-Subscribe"><a href="#6-2-Dns-Push-Notification-Subscribe" class="headerlink" title="6.2. Dns Push Notification Subscribe"></a>6.2. Dns Push Notification Subscribe</h2><p>[RFC8490]<br>After connecting, and requesting a longer idle timeout and/or keepalive interval if necessary, a DNS Push Notification client then indicates its desire to receive DNS Push Notifications for a given domain name by sending a SUBSCRIBE request to the server. A SUBSCRIBE request is encoded in a DSO message<br>. This specification defines a DSO Primary TLV for DNS Push Notification SUBSCRIBE Requests (DSO Type Code 0x0040). DSO messages with the SUBSCRIBE TLV as the Primary TLV are permitted in TLS early data, provided that the precautions described in Section 7.3 are followed.</p>
<p>MUST NOT<br>MUST<br>The entity that initiates a SUBSCRIBE request is by definition the client. A server send a SUBSCRIBE request over an existing session from a client. If a server does send a SUBSCRIBE request over a DSO session initiated by a client, this is a fatal error and the client forcibly abort the connection immediately.</p>
<p>MUST NOT<br>MUST<br>Each SUBSCRIBE request generates exactly one SUBSCRIBE response from the server. The entity that initiates a SUBSCRIBE response is by definition the server. A client send a SUBSCRIBE response. If a client does send a SUBSCRIBE response, this is a fatal error and the server forcibly abort the connection immediately.</p>
<h2 id="6-2-1-Subscribe-Request"><a href="#6-2-1-Subscribe-Request" class="headerlink" title="6.2.1. Subscribe Request"></a>6.2.1. Subscribe Request</h2><p>[RFC8490]<br>A SUBSCRIBE request begins with the standard DSO 12-byte header<br>, followed by the SUBSCRIBE Primary TLV. A SUBSCRIBE request is illustrated in Figure 1.</p>
<p>MUST<br>MUST<br>The MESSAGE ID field be set to a unique value that the client is not using for any other active operation on this DSO session. For the purposes here, a MESSAGE ID is in use on this session if either the client has used it in a request for which it has not yet received a response, or if the client has used it for a subscription that it has not yet canceled using UNSUBSCRIBE. In the SUBSCRIBE response, the server echo back the MESSAGE ID value unchanged.</p>
<p>MUST<br>DSO specification [RFC8490]<br>The other header fields be set as described in the<br>. The DNS<br>OPCODE field contains the OPCODE value for DNS Stateful Operations (6). The four count fields must be zero, and the corresponding four sections must be empty (i.e., absent).</p>
<h2 id="The-Dso-Type-Is-Subscribe-0X0040"><a href="#The-Dso-Type-Is-Subscribe-0X0040" class="headerlink" title="The Dso-Type Is Subscribe (0X0040)."></a>The Dso-Type Is Subscribe (0X0040).</h2><p>The DSO-LENGTH is the length of the DSO-DATA that follows, which specifies the name, type, and class of the record(s) being sought.</p>
<pre><code>                               1  1  1  1  1  1 0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+  \ |                  MESSAGE ID                   |   \ +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    | |QR| OPCODE(6) |         Z          |   RCODE   |    |
</code></pre>
<p>   +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+    | |             QDCOUNT (MUST BE ZERO)            |    | +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+     &gt; HEADER |             ANCOUNT (MUST BE ZERO)            |    | +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+    | |             NSCOUNT (MUST BE ZERO)            |    | +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+    | |             ARCOUNT (MUST BE ZERO)            |   / +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+  / |         DSO-TYPE = SUBSCRIBE (0x0040)         | +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+ |   DSO-LENGTH (number of octets in DSO-DATA)   | +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+  \ \                     NAME                      \   \ +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+    | |                     TYPE                      |     &gt; DSO-DATA +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+    | |                     CLASS                     |   / +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+  /</p>
<p>MUST<br>The DSO-DATA for a SUBSCRIBE request contain exactly one NAME, TYPE, and CLASS. Since SUBSCRIBE requests are sent over TCP, multiple SUBSCRIBE DSO request messages can be concatenated in a single TCP stream and packed efficiently into TCP segments. If accepted, the subscription will stay in effect until the client cancels the subscription using UNSUBSCRIBE or until the DSO session between the client and the server is closed.</p>
<p>MUST<br>MUST NOT<br>[RFC0020]<br>MUST<br>SUBSCRIBE requests on a given session be unique. A client send a SUBSCRIBE<br>message that duplicates the name, type and class of an existing active subscription on that DSO session. For the purpose of this matching, the established DNS case insensitivity for US-ASCII letters applies (e.g., “example.com” and “Example.com” are the same). If a server receives such a duplicate SUBSCRIBE message, this is a fatal error and the server forcibly abort the connection immediately. DNS wildcarding is not supported. That is, an asterisk character (“<em>“) in a SUBSCRIBE message matches only a literal asterisk character (“</em>“) in a name and nothing else. Similarly, a CNAME in a SUBSCRIBE message matches only a CNAME record with that name in the zone and no other records with that name.</p>
<p>A client may SUBSCRIBE to records that are unknown to the server at the time of the request (providing that the name falls within one of the zone(s) the server is responsible for), and this is not an error. The server return NXDOMAIN in this case. The server accept these requests and send Push Notifications if and when matching records are found in the future. If neither TYPE nor CLASS are ANY (255), then this is a specific subscription to changes for the given name, type, and class. If one or both of TYPE or CLASS are ANY (255), then this subscription matches all types and/or all classes as appropriate. NOTE: A little-known quirk of DNS is that in DNS QUERY requests, QTYPE and QCLASS 255 mean<br>“ANY”, not “ALL”. They indicate that the server should respond with ANY matching records of its choosing, not necessarily ALL matching records. This can lead to some surprising and unexpected results, where a query returns some valid answers, but not all of them, and makes QTYPE = 255 (ANY) queries less useful than people sometimes imagine. When used in conjunction with SUBSCRIBE, TYPE 255 and CLASS 255 should be interpreted to mean “ALL”, not “ANY”. After accepting a subscription where one or both of TYPE or CLASS are 255, the server send Push Notification Updates for ALL record changes that match the subscription, not just some of them.</p>
<h2 id="6-2-2-Subscribe-Response"><a href="#6-2-2-Subscribe-Response" class="headerlink" title="6.2.2. Subscribe Response"></a>6.2.2. Subscribe Response</h2><p>[RFC8490]<br>MAY<br>A SUBSCRIBE response begins with the standard DSO 12-byte header<br>. The QR bit in the header is set indicating it is a response. The header be followed by one or more optional Additional TLVs such as a Retry Delay Additional TLV. A SUBSCRIBE response is illustrated in Figure 2.</p>
<p>MUST<br>The MESSAGE ID field echo the value given in the MESSAGE ID field of the SUBSCRIBE<br>request. This is how the client knows which request is being responded to.</p>
<p>MUST<br>DSO specification [RFC8490]<br>The other header fields be set as described in the<br>. The DNS<br>OPCODE field contains the OPCODE value for DNS Stateful Operations (6). The four count fields must be zero, and the corresponding four sections must be empty (i.e., absent).</p>
<p>MUST NOT<br>MUST<br>A SUBSCRIBE response message include a SUBSCRIBE TLV. If a client receives a SUBSCRIBE response message containing a SUBSCRIBE TLV, then the response message is processed but the SUBSCRIBE TLV<br> be silently ignored.</p>
<pre><code>                               1  1  1  1  1  1
 0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
</code></pre>
<p>   +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+  <br>   |                  MESSAGE ID                   |   <br>   +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+    |<br>   |QR| OPCODE(6) |         Z          |   RCODE   |    |<br>   +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+    |<br>   |             QDCOUNT (MUST BE ZERO)            |    |<br>   +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+     &gt; HEADER<br>   |             ANCOUNT (MUST BE ZERO)            |    |<br>   +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+    |<br>   |             NSCOUNT (MUST BE ZERO)            |    |<br>   +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+    |<br>   |             ARCOUNT (MUST BE ZERO)            |   /<br>   +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+  /</p>
<p>In the SUBSCRIBE response, the RCODE indicates whether or not the subscription was accepted. Supported RCODEs are as follows:</p>
<table>
<thead>
<tr>
<th>Mnemonic</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>NOERROR</td>
<td>0</td>
<td>SUBSCRIBE successful.</td>
</tr>
<tr>
<td>FORMERR</td>
<td>1</td>
<td>Server failed to process request due to a malformed request.</td>
</tr>
<tr>
<td>SERVFAIL</td>
<td>2</td>
<td>Server failed to process request due to a problem with the server.</td>
</tr>
<tr>
<td>NOTIMP</td>
<td>4</td>
<td>Server does not implement DSO.</td>
</tr>
<tr>
<td>REFUSED</td>
<td>5</td>
<td>Server refuses to process request for policy or security reasons.</td>
</tr>
<tr>
<td>NOTAUTH</td>
<td>9</td>
<td>Server is not authoritative for the requested name.</td>
</tr>
<tr>
<td>DSOTYPENI</td>
<td>11</td>
<td>SUBSCRIBE operation not supported.</td>
</tr>
</tbody></table>
<p>SHOULD<br>MUST<br>This document specifies only these RCODE values for SUBSCRIBE Responses. Servers sending SUBSCRIBE Responses use one of these values. Note that NXDOMAIN is not a valid RCODE in response to a SUBSCRIBE Request. However, future circumstances may create situations where other RCODE values are appropriate in SUBSCRIBE Responses, so clients be prepared to accept and handle SUBSCRIBE Responses with any other nonzero RCODE error values. If the server sends a nonzero RCODE in the SUBSCRIBE response, that means:</p>
<p>a.<br>b.<br>the client is (at least partially) misconfigured, or the server resources are exhausted, or<br>c. </p>
<p>there is some other unknown failure on the server. </p>
<h2 id="May"><a href="#May" class="headerlink" title="May"></a>May</h2><p>In any case, the client shouldn’t retry the subscription to this server right away. If multiple SRV records were returned as described in Section 6.1, Paragraph 9, Item 7, a subsequent server be tried immediately.</p>
<p>If the client has other successful subscriptions to this server, these subscriptions remain even though additional subscriptions may be refused. Neither the client nor the server is required to close the connection, although either end may choose to do so.</p>
<p>SHOULD<br>[RFC8490] If the server sends a nonzero RCODE, then it append a Retry Delay Additional TLV<br> to the response specifying a delay before the client attempts this operation again.</p>
<p>Recommended values for the delay for different RCODE values are given below. These recommended values apply both to the default values a server should place in the Retry Delay Additional TLV and the default values a client should assume if the server provides no Retry Delay Additional TLV.</p>
<p>For RCODE = 1 (FORMERR), the delay may be any value selected by the implementer. A value of five minutes is to reduce the risk of high load from defective clients. </p>
<p>For RCODE = 2 (SERVFAIL), the delay should be chosen according to the level of server overload and the anticipated duration of that overload. By default, a value of one minute is<br>. If a more serious server failure occurs, the delay may be longer in accordance with the specific problem encountered. </p>
<p>[RFC8490]</p>
<p>For RCODE = 4 (NOTIMP), which occurs on a server that doesn’t implement DNS Stateful Operations<br>, it is unlikely that the server will begin supporting DSO in the next few minutes, so the retry delay be one hour. Note that in such a case, a server that doesn’t implement DSO is unlikely to place a Retry Delay Additional TLV in its response, so this recommended value in particular applies to what a client should assume by default. For RCODE = 5 (REFUSED), which occurs on a server that implements DNS Push Notifications but is currently configured to disallow DNS Push Notifications, the retry delay may be any value selected by the implementer and/or configured by the operator. </p>
<p>If the server being queried is listed in a _dns‑push‑tls._tcp.<zone> SRV record for the zone, then this is a misconfiguration, since this server is being advertised as supporting DNS Push Notifications for this zone, but the server itself is not currently configured to perform that task. Since it is possible that the misconfiguration may be repaired at any time, the retry delay should not be set too high. By default, a value of 5 minutes is<br>. </p>
<p>For RCODE = 9 (NOTAUTH), which occurs on a server that implements DNS Push Notifications but is not configured to be authoritative for the requested name, the retry delay may be any value selected by the implementer and/or configured by the operator. </p>
<p>RECOMMENDED</p>
<p>If the server being queried is listed in a _dns‑push‑tls._tcp.<zone> SRV record for the zone, then this is a misconfiguration, since this server is being advertised as supporting DNS Push Notifications for this zone, but the server itself is not currently configured to perform that task. Since it is possible that the misconfiguration may be repaired at any time, the retry delay should not be set too high. By default, a value of 5 minutes is<br>. </p>
<p>SHOULD<br>For RCODE = 11 (DSOTYPENI), which occurs on a server that implements DSO but doesn’t implement DNS Push Notifications, it is unlikely that the server will begin supporting DNS Push Notifications in the next few minutes, so the retry delay be one hour. </p>
<p>For other RCODE values, the retry delay should be set by the server as appropriate for that error condition. By default, a value of 5 minutes is<br>. </p>
<p>For RCODE = 9 (NOTAUTH), the time delay applies to requests for other names falling within the same zone. Requests for names falling within other zones are not subject to the delay. For all other RCODEs, the time delay applies to all subsequent requests to this server.</p>
<p>MAY<br>MAY<br>DSO specification [RFC8490]<br>MUST<br>After sending an error response, the server allow the session to remain open, or follow it with a DSO Retry Delay operation (using the Retry Delay Primary TLV) instructing the client to close the session as described in the<br>. Clients correctly handle both cases. Note that the DSO Retry Delay operation (using the Retry Delay Primary TLV) is different to the Retry Delay Additional TLV mentioned above.</p>
<h2 id="6-3-Dns-Push-Notification-Updates"><a href="#6-3-Dns-Push-Notification-Updates" class="headerlink" title="6.3. Dns Push Notification Updates"></a>6.3. Dns Push Notification Updates</h2><p>Once a subscription has been successfully established, the server generates PUSH messages to send to the client as appropriate. In the case that the answer set was already non-empty at the moment the subscription was established, an initial PUSH message will be sent immediately following the SUBSCRIBE Response. Subsequent changes to the answer set are then communicated to the client in subsequent PUSH messages.</p>
<p>MUST NOT<br>MUST<br>A client send a PUSH message. If a client does send a PUSH message, or a PUSH<br>message is sent with the QR bit set indicating that it is a response, this is a fatal error and the receiver forcibly abort the connection immediately.</p>
<h2 id="6-3-1-Push-Message"><a href="#6-3-1-Push-Message" class="headerlink" title="6.3.1. Push Message"></a>6.3.1. Push Message</h2><p>[RFC8490]<br>A PUSH unidirectional message begins with the standard DSO 12-byte header<br>, followed by the PUSH Primary TLV. A PUSH message is illustrated in Figure 3.</p>
<p>MUST<br>In accordance with the definition of DSO unidirectional messages, the MESSAGE ID field be zero. There is no client response to a PUSH message.</p>
<p>MUST<br>[RFC8490]<br>The other header fields be set as described in the DSO specification<br>. The DNS<br>OPCODE field contains the OPCODE value for DNS Stateful Operations (6). The four count fields must be zero, and the corresponding four sections must be empty (i.e., absent). The DSO-TYPE is PUSH (0x0041). The DSO-LENGTH is the length of the DSO-DATA that follows, which specifies the changes being communicated.</p>
<p>MUST<br>MUST<br>The DSO-DATA contains one or more change notifications. A PUSH Message contain at least one change notification. If a PUSH Message is received that contains no change notifications, this is a fatal error and the client forcibly abort the connection immediately.</p>
<p>The change notification records are formatted similarly to how DNS Resource Records are conventionally expressed in DNS messages, as illustrated in Figure 3, and are interpreted as described below.</p>
<p>The TTL field holds an unsigned 32-bit integer<br>. If the TTL is in the range 0 to<br>[RFC2181]<br>MUST NOT<br>MUST<br>2,147,483,647 seconds (0 to 231 - 1, or 0x7FFFFFFF), then a new DNS Resource Record with the given name, type, class, and RDATA is added. Type and class be 255 (ANY). If either type or class are 255 (ANY), this is a fatal error and the client forcibly abort the connection immediately. A TTL of 0 means that this record should be retained for as long as the subscription is active and should be discarded immediately the moment the subscription is canceled.</p>
<p>MUST NOT<br>MUST<br>If the TTL has the value 0xFFFFFFFF, then the DNS Resource Record with the given name, type, class, and RDATA is removed. Type and class be 255 (ANY). If either type or class are<br>255 (ANY), this is a fatal error and the client forcibly abort the connection immediately.</p>
<p>MUST<br>MUST<br>MUST<br>If the TTL has the value 0xFFFFFFFE, then this is a ‘collective’ remove notification. For collective remove notifications, RDLEN<br> be zero, and consequently, the RDATA<br> be empty. If a change notification is received where TTL = 0xFFFFFFFE and RDLEN is not zero, this is a fatal error and the client forcibly abort the connection immediately.</p>
<p>There are three types of collective remove notification. For collective remove notifications:</p>
<ul>
<li><p>If CLASS is not 255 (ANY) and TYPE is not 255 (ANY), then for the given name, this removes all records of the specified type in the specified class. </p>
</li>
<li><p>If CLASS is not 255 (ANY) and TYPE is 255 (ANY), then for the given name, this removes all records of all types in the specified class. </p>
</li>
<li><p>MUST<br>MUST<br>If CLASS is 255 (ANY), then for the given name, this removes all records of all types in all classes. In this case, TYPE<br>be set to zero on transmission and<br>be silently ignored<br>on reception.<br>Summary of change notification types:</p>
</li>
<li><p>Remove all RRsets from a name in all classes: TTL = 0xFFFFFFFE, RDLEN = 0, CLASS = 255 (ANY).</p>
</li>
<li><p>Remove all RRsets from a name in given class: TTL = 0xFFFFFFFE, RDLEN = 0, CLASS gives class, TYPE = 255 (ANY).</p>
</li>
<li><p>Remove specified RRset from a name in given class: TTL = 0xFFFFFFFE, RDLEN = 0, CLASS and TYPE specify the RRset being removed.</p>
</li>
<li><p>Remove an individual RR from a name: TTL = 0xFFFFFFFF, CLASS, TYPE, RDLEN, and RDATA specify the RR being removed.</p>
</li>
<li><p>Add individual RR to a name: TTL &gt;= 0 and TTL &lt;= 0x7FFFFFFF, CLASS, TYPE, RDLEN, RDATA, and TTL specify the RR being added.<br>[RFC3123]<br>Note that it is valid for the RDATA of an added or removed DNS Resource Record to be empty<br>(zero length). For example, an Address Prefix List Resource Record may have empty RDATA. Therefore, a change notification with RDLEN = 0 does not automatically indicate a remove notification. If RDLEN = 0 and TTL is in the range 0 to 0x7FFFFFFF, this change notification signals the addition of a record with the given name, type, class, and empty RDATA. If RDLEN = 0 and TTL = 0xFFFFFFFF, this change notification signals the removal specifically of that single record with the given name, type, class, and empty RDATA.</p>
</li>
</ul>
<p>If the TTL is any value other than 0xFFFFFFFF, 0xFFFFFFFE, or a value in the range 0 to 0x7FFFFFFF, then the receiver silently ignore this particular change notification record.</p>
<p>The connection is not terminated and other valid change notification records within this PUSH<br>message are processed as usual. In the case where a single change affects more than one active subscription, only one PUSH message is sent. For example, a PUSH message adding a given record may match both a SUBSCRIBE request with the same TYPE and a different SUBSCRIBE request with TYPE = 255 (ANY). It is not the case that two PUSH messages are sent because the new record matches two active subscriptions.</p>
<p>SHOULD</p>
<p>SHOULD<br>The server encode change notifications in the most efficient manner possible. For example, when three AAAA records are removed from a given name, and no other AAAA records exist for that name, the server send a “Remove specified RRset from a name in given class” PUSH message, not three separate “Remove an individual RR from a name” PUSH messages. Similarly, when both an SRV and a TXT record are removed from a given name, and no other records of any kind exist for that name in that class, the server send a “Remove all RRsets from a name in given class” PUSH message, not two separate “Remove specified RRset from a name in given class” PUSH messages.</p>
<h2 id="Should-Should"><a href="#Should-Should" class="headerlink" title="Should Should"></a>Should Should</h2><p>For efficiency, when generating a PUSH message, rather than sending each change notification as a separate DSO message, a server include as many change notifications as it has immediately available to send to that client, even if those change notifications apply to different subscriptions from that client. Conceptually, a PUSH message is a session-level mechanism, not a subscription-level mechanism. Once it has exhausted the list of change notifications immediately available to send to that client, a server then send the PUSH message immediately rather than waiting speculatively to see if additional change notifications become available.</p>
<p>SHOULD<br>[RFC1035]<br>Section 18.14 of the Multicast DNS specification [RFC6762]<br>For efficiency, when generating a PUSH message a server use standard DNS name compression, with offsets relative to the beginning of the DNS message<br>. When multiple change notifications in a single PUSH message have the same owner name, this name compression can yield significant savings. Name compression should be performed as specified in<br>; namely, owner names should always be compressed, and names appearing within RDATA should be compressed for only the RR types listed below:</p>
<h2 id="Ns-Cname-Ptr-Dname-Soa-Mx-Afsdb-Rt-Kx-Rp-Px-Srv-Nsec-Must-Not-Must"><a href="#Ns-Cname-Ptr-Dname-Soa-Mx-Afsdb-Rt-Kx-Rp-Px-Srv-Nsec-Must-Not-Must" class="headerlink" title="Ns, Cname, Ptr, Dname, Soa, Mx, Afsdb, Rt, Kx, Rp, Px, Srv, Nsec Must Not Must"></a>Ns, Cname, Ptr, Dname, Soa, Mx, Afsdb, Rt, Kx, Rp, Px, Srv, Nsec Must Not Must</h2><p>Servers may generate PUSH messages up to a maximum DNS message length of 16,382 bytes, counting from the start of the DSO 12-byte header. Including the two-byte length prefix that is used to frame DNS over a byte stream like TLS, this makes a total of 16,384 bytes. Servers generate PUSH messages larger than this. Where the immediately available change notifications are sufficient to exceed a DNS message length of 16,382 bytes, the change notifications be communicated in separate PUSH messages of up to 16,382 bytes each. DNS<br>name compression becomes less effective for messages larger than 16,384 bytes, so little efficiency benefit is gained by sending messages larger than this.</p>
<p>MUST<br>If a client receives a PUSH message with a DNS message length larger than 16,382 bytes, this is a fatal error and the client forcibly abort the connection immediately.</p>
<pre><code>                               1  1  1  1  1  1
 0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
</code></pre>
<p>   +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+  <br>   |           MESSAGE ID (MUST BE ZERO)           |   <br>   +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+    |<br>   |QR| OPCODE(6) |         Z          |   RCODE   |    |<br>   +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+    |<br>   |             QDCOUNT (MUST BE ZERO)            |    |<br>   +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+     &gt; HEADER<br>   |             ANCOUNT (MUST BE ZERO)            |    |<br>   +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+    |<br>   |             NSCOUNT (MUST BE ZERO)            |    |<br>   +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+    |<br>   |             ARCOUNT (MUST BE ZERO)            |   /<br>   +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+  /<br>   |            DSO-TYPE = PUSH (0x0041)           |<br>   +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+<br>   |   DSO-LENGTH (number of octets in DSO-DATA)   |<br>   +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+  <br>   \                     NAME                      \   <br>   +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+    |<br>   |                     TYPE                      |    |<br>   +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+    |<br>   |                     CLASS                     |    |<br>   +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+    |<br>   |                      TTL                      |    |<br>   |     (32-bit unsigned big-endian integer)      |     &gt; DSO-DATA<br>   +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+    |<br>   |  RDLEN (16-bit unsigned big-endian integer)   |    |<br>   +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+    |<br>   \           RDATA (sized as necessary)          \    |<br>   +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+    |<br>   :     NAME, TYPE, CLASS, TTL, RDLEN, RDATA      :    |<br>   :             Repeated As Necessary             :   /<br>   +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+  /</p>
<p>MUST<br>MUST<br>When processing the records received in a PUSH Message, the receiving client validate that the records being added or removed correspond with at least one currently active subscription on that session. Specifically, the record name match the name given in the SUBSCRIBE<br>request, subject to the usual established DNS case-insensitivity for US-ASCII letters. For individual additions and removals, if the TYPE in the SUBSCRIBE request was not ANY (255), then the TYPE of the record must either be CNAME or match the TYPE given in the SUBSCRIBE request, and if the CLASS in the SUBSCRIBE request was not ANY (255), then the CLASS of the record must match the CLASS given in the SUBSCRIBE request. For collective removals, at least one of the records being removed must match an active subscription. If a matching active subscription on that session is not found, then that particular addition/removal record is silently ignored. The processing of other additions and removal records in this message is not affected. The DSO session is not closed. This is to allow for the unavoidable race condition where a client sends an outbound UNSUBSCRIBE while inbound PUSH messages for that subscription from the server are still in flight.</p>
<p>SHOULD<br>The TTL of an added record is stored by the client. While the subscription is active the TTL is not decremented, because a change to the TTL would produce a new update. For as long as a relevant subscription remains active, the client assume that when a record goes away, the server will notify it of that fact. Consequently, a client does not have to poll to verify that the record is still there. Once a subscription is canceled (individually, or as a result of the DSO session being closed), record aging for records covered by the subscription resumes and records are removed from the local cache when their TTL reaches zero.</p>
<h2 id="6-4-Dns-Push-Notification-Unsubscribe"><a href="#6-4-Dns-Push-Notification-Unsubscribe" class="headerlink" title="6.4. Dns Push Notification Unsubscribe"></a>6.4. Dns Push Notification Unsubscribe</h2><p>To cancel an individual subscription without closing the entire DSO session, the client sends an UNSUBSCRIBE message over the established DSO session to the server.</p>
<p>MUST NOT<br>MUST<br>The entity that initiates an UNSUBSCRIBE message is by definition the client. A server send an UNSUBSCRIBE message over an existing session from a client. If a server does send an UNSUBSCRIBE message over a DSO session initiated by a client, or an UNSUBSCRIBE message is sent with the QR bit set indicating that it is a response, this is a fatal error and the receiver forcibly abort the connection immediately.</p>
<h2 id="6-4-1-Unsubscribe-Message"><a href="#6-4-1-Unsubscribe-Message" class="headerlink" title="6.4.1. Unsubscribe Message"></a>6.4.1. Unsubscribe Message</h2><p>[RFC8490] An UNSUBSCRIBE unidirectional message begins with the standard DSO 12-byte header<br>, followed by the UNSUBSCRIBE Primary TLV. An UNSUBSCRIBE message is illustrated in Figure 4.</p>
<p>MUST<br>In accordance with the definition of DSO unidirectional messages, the MESSAGE ID field be zero. There is no server response to an UNSUBSCRIBE message.</p>
<p>MUST<br>DSO specification [RFC8490]<br>The other header fields be set as described in the<br>. The DNS<br>OPCODE field contains the OPCODE value for DNS Stateful Operations (6). The four count fields must be zero, and the corresponding four sections must be empty (i.e., absent). The DSO-TYPE is UNSUBSCRIBE (0x0042). The DSO-LENGTH field contains the value 2, the length of the 2-octet MESSAGE ID contained in the DSO-DATA. The DSO-DATA contains the value previously given in the MESSAGE ID field of an active SUBSCRIBE request. This is how the server knows which SUBSCRIBE request is being canceled.</p>
<p>After receipt of the UNSUBSCRIBE message, the SUBSCRIBE request is no longer active. It is allowable for the client to issue an UNSUBSCRIBE message for a previous SUBSCRIBE request for which the client has not yet received a SUBSCRIBE response. This is to allow for the case where a client starts and stops a subscription in less than the round-trip time to the server. The client is NOT required to wait for the SUBSCRIBE response before issuing the UNSUBSCRIBE message.</p>
<p>MUST<br>Consequently, it is possible for a server to receive an UNSUBSCRIBE message that does not match any currently active subscription. This can occur when a client sends a SUBSCRIBE request, which subsequently fails and returns an error code, but the client sent an UNSUBSCRIBE message before it became aware that the SUBSCRIBE request had failed. Because of this, servers silently ignore UNSUBSCRIBE messages that do not match any currently active subscription.</p>
<pre><code>                               1  1  1  1  1  1
 0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
</code></pre>
<p>   +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+  <br>   |           MESSAGE ID (MUST BE ZERO)           |   <br>   +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+    |<br>   |QR| OPCODE(6) |         Z          |   RCODE   |    |<br>   +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+    |<br>   |             QDCOUNT (MUST BE ZERO)            |    |<br>   +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+     &gt; HEADER<br>   |             ANCOUNT (MUST BE ZERO)            |    |<br>   +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+    |<br>   |             NSCOUNT (MUST BE ZERO)            |    |<br>   +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+    |<br>   |             ARCOUNT (MUST BE ZERO)            |   /<br>   +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+  /<br>   |         DSO-TYPE = UNSUBSCRIBE (0x0042)       |<br>   +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+<br>   |                DSO-LENGTH (2)                 |<br>   +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+  <br>   |              SUBSCRIBE MESSAGE ID             |   &gt; DSO-DATA<br>   +–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+  /</p>
<h2 id="6-5-Dns-Push-Notification-Reconfirm"><a href="#6-5-Dns-Push-Notification-Reconfirm" class="headerlink" title="6.5. Dns Push Notification Reconfirm"></a>6.5. Dns Push Notification Reconfirm</h2><p>[RFC8766]<br>Sometimes, particularly when used with a Discovery Proxy<br>, a DNS Zone may contain stale data. When a client encounters data that it believes may be stale (e.g., an SRV record referencing a target host+port that is not responding to connection requests), the client can send a RECONFIRM message to ask the server to re-verify that the data is still valid. For a Discovery<br>[SD-API]<br>Proxy, this causes it to issue new Multicast DNS queries to ascertain whether the target device is still present. How the Discovery Proxy causes these new Multicast DNS queries to be issued depends on the details of the underlying Multicast DNS implementation being used. For example, a Discovery Proxy built on Apple’s dns_sd.h API<br> responds to a DNS Push Notification RECONFIRM message by calling the underlying API’s DNSServiceReconfirmRecord() routine.</p>
<p>SHOULD<br>For other types of DNS server, the RECONFIRM operation is currently undefined and result in a NOERROR response, but it need not cause any other action to occur.</p>
<p>MAY<br>Frequent use of RECONFIRM operations may be a sign of network unreliability, or some kind of misconfiguration, so RECONFIRM operations be logged or otherwise communicated to a human administrator to assist in detecting and remedying such network problems. If, after receiving a valid RECONFIRM message, the server determines that the disputed records are in fact no longer valid, then subsequent DNS PUSH Messages will be generated to inform interested clients. Thus, one client discovering that a previously advertised device (like a network printer) is no longer present has the side effect of informing all other interested clients that the device in question is now gone.</p>
<p>MUST NOT<br>MUST<br>The entity that initiates a RECONFIRM message is by definition the client. A server send a RECONFIRM message over an existing session from a client. If a server does send a RECONFIRM message over a DSO session initiated by a client, or a RECONFIRM message is sent with the QR bit set indicating that it is a response, this is a fatal error and the receiver forcibly abort the connection immediately.</p>
<h2 id="6-5-1-Reconfirm-Message"><a href="#6-5-1-Reconfirm-Message" class="headerlink" title="6.5.1. Reconfirm Message"></a>6.5.1. Reconfirm Message</h2><p>[RFC8490]<br>A RECONFIRM unidirectional message begins with the standard DSO 12-byte header<br>, followed by the RECONFIRM Primary TLV. A RECONFIRM message is illustrated in Figure 5.</p>
<p>MUST<br>In accordance with the definition of DSO unidirectional messages, the MESSAGE ID field be zero. There is no server response to a RECONFIRM message.</p>
<p>MUST<br>DSO specification [RFC8490]<br>The other header fields be set as described in the<br>. The DNS<br>OPCODE field contains the OPCODE value for DNS Stateful Operations (6). The four count fields must be zero, and the corresponding four sections must be empty (i.e., absent). The DSO-TYPE is RECONFIRM (0x0043). The DSO-LENGTH is the length of the data that follows, which specifies the name, type, class, and content of the record being disputed.</p>
<p>MUST<br>A DNS Push Notifications RECONFIRM message contains exactly one RECONFIRM Primary TLV. The DSO-DATA in a RECONFIRM Primary TLV<br> contain exactly one record. The DSO-DATA in a RECONFIRM Primary TLV has no count field to specify more than one record. Since RECONFIRM messages are sent over TCP, multiple RECONFIRM messages can be concatenated in a single TCP stream and packed efficiently into TCP segments. Note that this means that DNS name compression cannot be used between different RECONFIRM messages. However, when a client is sending multiple RECONFIRM messages this indicates a situation with serious network problems, and this is not expected to occur frequently enough that optimizing efficiency in this case is important.</p>
<p>MUST NOT<br>MUST NOT<br>TYPE<br> be the value ANY (255) and CLASS<br> be the value ANY (255).</p>
<p>DNS wildcarding is not supported. That is, an asterisk character (“<em>“) in a RECONFIRM message matches only a literal asterisk character (“</em>“) in a name and nothing else. Similarly, a CNAME in a RECONFIRM message matches only a CNAME record with that name in the zone and no other records with that name. Note that there is no RDLEN field, since the length of the RDATA can be inferred from DSO- LENGTH, so an additional RDLEN field would be redundant. Following the same rules as for PUSH messages, DNS name compression SHOULD be used within the RDATA of the RECONFIRM message, with offsets relative to the beginning of the DNS message<br>.</p>
<p>[RFC1035]</p>
<pre><code>                               1  1  1  1  1  1 0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+  \ |           MESSAGE ID (MUST BE ZERO)           |   \ +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    | |QR| OPCODE(6) |         Z          |   RCODE   |    | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    | |             QDCOUNT (MUST BE ZERO)            |    | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+     &gt; HEADER |             ANCOUNT (MUST BE ZERO)            |    | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    | |             NSCOUNT (MUST BE ZERO)            |    | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    | |             ARCOUNT (MUST BE ZERO)            |   / +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+  / |         DSO-TYPE = RECONFIRM (0x0043)         | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ |   DSO-LENGTH (number of octets in DSO-DATA)   | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+  \ \                     NAME                      \   \ +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    | |                     TYPE                      |    | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+     &gt; DSO-DATA |                     CLASS                     |    | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    | \                     RDATA                     \   / +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+  /
</code></pre>
<h2 id="6-6-Dns-Stateful-Operations-Tlv-Context-Summary"><a href="#6-6-Dns-Stateful-Operations-Tlv-Context-Summary" class="headerlink" title="6.6. Dns Stateful Operations Tlv Context Summary"></a>6.6. Dns Stateful Operations Tlv Context Summary</h2><p>Section 8.2 of the DNS Stateful Operations specification [RFC8490]<br>This document defines four new DSO TLVs. As recommended in<br>, the valid contexts of these new TLV types are summarized below. The client TLV contexts are: C-P: C-U: C-A: CRP: CRA:<br>Client request message, Primary TLV Client Unidirectional message, primary TLV Client request or unidirectional message, Additional TLV<br>Response back to client, Primary TLV<br>Response back to client, Additional TLV </p>
<table>
<thead>
<tr>
<th>TLV Type</th>
<th>C-P</th>
</tr>
</thead>
<tbody><tr>
<td>SUBSCRIBE</td>
<td>X</td>
</tr>
<tr>
<td>PUSH</td>
<td></td>
</tr>
<tr>
<td>UNSUBSCRIBE</td>
<td>X</td>
</tr>
<tr>
<td>RECONFIRM</td>
<td>X</td>
</tr>
</tbody></table>
<p>The server TLV contexts are:<br>S-P: S-U: S-A: SRP: SRA:<br>Server request message, Primary TLV Server Unidirectional message, primary TLV Server request or unidirectional message, Additional TLV<br>Response back to server, Primary TLV<br>Response back to server, Additional TLV </p>
<table>
<thead>
<tr>
<th>TLV Type</th>
<th>S-P</th>
</tr>
</thead>
<tbody><tr>
<td>SUBSCRIBE</td>
<td></td>
</tr>
<tr>
<td>PUSH</td>
<td>X</td>
</tr>
<tr>
<td>UNSUBSCRIBE</td>
<td></td>
</tr>
</tbody></table>
<p>RECONFIRM</p>
<h2 id="6-7-Client-Initiated-Termination"><a href="#6-7-Client-Initiated-Termination" class="headerlink" title="6.7. Client-Initiated Termination"></a>6.7. Client-Initiated Termination</h2><p>An individual subscription is terminated by sending an UNSUBSCRIBE TLV for that specific subscription, or all subscriptions can be canceled at once by the client closing the DSO session.</p>
<p>When a client terminates an individual subscription (via UNSUBSCRIBE) or all subscriptions on that DSO session (by ending the session), it is signaling to the server that it is no longer interested in receiving those particular updates. It is informing the server that the server may release any state information it has been keeping with regards to these particular subscriptions.</p>
<p>MAY<br>After terminating its last subscription on a session via UNSUBSCRIBE, a client close the session immediately or it may keep it open if it anticipates performing further operations on that session in the future. If a client wishes to keep an idle session open, it respect the maximum idle time required by the server<br>.</p>
<p>MUST<br>[RFC8490]<br>MAY<br>If a client plans to terminate one or more subscriptions on a session and doesn’t intend to keep that session open, then as an efficiency optimization, it instead choose to simply close the session, which implicitly terminates all subscriptions on that session. This may occur because the client computer is being shut down, is going to sleep, the application requiring the subscriptions has terminated, or simply because the last active subscription on that session has been canceled.</p>
<p>Section<br>6.1 of the TLS 1.3 specification [RFC8446]<br>MUST<br>When closing a session, a client should perform an orderly close of the TLS session. Typical APIs will provide a session close method that will send a TLS close_notify alert as described in<br>. This instructs the recipient that the sender will not send any more data over the session. After sending the TLS close_notify alert, the client gracefully close the underlying connection using a TCP FIN so that the TLS close_notify is reliably delivered. The mechanisms for gracefully closing a TCP connection with a TCP FIN vary depending on the networking API. For example, in the BSD Sockets API, sending a TCP FIN is achieved by calling “shutdown(s,SHUT_WR)” and keeping the socket open until all remaining data has been read from it. If the session is forcibly closed at the TCP level by sending a RST from either end of the connection, data may be lost.</p>
<h2 id="6-8-Client-Fallback-To-Polling"><a href="#6-8-Client-Fallback-To-Polling" class="headerlink" title="6.8. Client Fallback To Polling"></a>6.8. Client Fallback To Polling</h2><p>There are cases where a client may exhaust all avenues for establishing a DNS Push Notification subscription without success. This can happen if the client’s configured recursive resolver does not support DNS over TLS, or supports DNS over TLS but is not listening on TCP port 853, or supports DNS over TLS on TCP port 853 but does not support DSO on that port, or for some other reason is unable to provide a DNS Push Notification subscription. In this case, the client will attempt to communicate directly with an appropriate server, and it may be that the zone apex discovery fails, or there is no _dns‑push‑tls._tcp.<zone> SRV record, or the server indicated in the SRV record is misconfigured, overloaded, or is unresponsive for some other reason. Regardless of the reason for the failure, after being unable to establish the desired DNS Push Notification subscription, it is likely that the client will still wish to know the answer it seeks, even if that answer cannot be obtained with the timely change notifications provided by DNS Push Notifications. In such cases, it is likely that the client will obtain the answer it seeks via a conventional DNS query instead, repeated at some interval to detect when the answer RRset changes.</p>
<p>In the case where a client responds to its failure to establish a DNS Push Notification subscription by falling back to polling with conventional DNS queries instead, the polling rate should be controlled to avoid placing excessive burden on the server. The interval between successive DNS queries for the same name, type, and class be at least the minimum of 900 seconds (15<br>minutes) or two seconds more than the TTL of the answer RRset. The reason that for TTLs up to 898 seconds the query should not be reissued until two seconds after the answer RRset has expired, is to ensure that the answer RRset has also expired from the cache on the client’s configured recursive resolver. Otherwise (particularly if the clocks on the client and the recursive resolver do not run at precisely the same rate), there’s a risk of a race condition where the client queries its configured recursive resolver just as the answer RRset has one second remaining in the recursive resolver’s cache. The client would receive a reply telling it that the answer RRset has one second remaining; the client would then requery the recursive resolver again one second later. If by this time the answer RRset has actually expired from the recursive resolver’s cache, the recursive resolver would then issue a new query to fetch fresh data from the authoritative server. Waiting until the answer RRset has definitely expired from the cache on the client’s configured recursive resolver avoids this race condition and any unnecessary additional queries it causes. Each time a client is about to reissue its query to discover changes to the answer RRset, it should first make a new attempt to establish a DNS Push Notification subscription using previously cached DNS answers as appropriate. After a temporary misconfiguration has been remedied, this allows a client that is polling to return to using DNS Push Notifications for asynchronous notification of changes.</p>
<h2 id="7-Security-Considerations"><a href="#7-Security-Considerations" class="headerlink" title="7. Security Considerations"></a>7. Security Considerations</h2><p>REQUIRED<br>[RFC8310]<br>The Strict Privacy profile for DNS over TLS is for DNS Push Notifications<br>.</p>
<p>Cleartext connections for DNS Push Notifications are not permissible. Since this is a new protocol, transition mechanisms from the Opportunistic Privacy profile are unnecessary.</p>
<p>Section 9 of the document Usage Profiles for DNS over (D)TLS [RFC8310]<br>Also, see for additional recommendations for various versions of TLS usage. As a consequence of requiring TLS, client certificate authentication and verification may also be enforced by the server for stronger client-server security or end-to-end security. However, recommendations for security in particular deployment scenarios are outside the scope of this document.</p>
<p>RECOMMENDED<br>DNSSEC is for the authentication of DNS Push Notification servers. TLS alone does not provide complete security. TLS certificate verification can provide reasonable assurance that the client is really talking to the server associated with the desired host name, but since the desired host name is learned via a DNS SRV query, if the SRV query is subverted, then the client may have a secure connection to a rogue server. DNSSEC can provide added confidence that the SRV query has not been subverted.</p>
<h2 id="7-1-Security-Services"><a href="#7-1-Security-Services" class="headerlink" title="7.1. Security Services"></a>7.1. Security Services</h2><p>It is the goal of using TLS to provide the following security services:</p>
<p>Confidentiality:<br>All application-layer communication is encrypted with the goal that no party<br>should be able to decrypt it except the intended receiver.<br>Data integrity protection:<br>Any changes made to the communication in transit are detectable by<br>the receiver.<br>Authentication:<br>An endpoint of the TLS communication is authenticated as the intended entity<br>to communicate with.<br>Anti-replay protection:<br>TLS provides for the detection of and prevention against messages sent<br>previously over a TLS connection (such as DNS Push Notifications). If prior messages are re-sent at a later time as a form of a man-in-the-middle attack, then the receiver will detect this and reject the replayed messages.<br>[BCP195]<br>Deployment recommendations on the appropriate key lengths and cipher suites are beyond the scope of this document. Please refer to the current TLS Recommendations for the best current practices. Keep in mind that best practices only exist for a snapshot in time, and recommendations will continue to change. Updated versions or errata may exist for these recommendations.</p>
<h2 id="7-2-Tls-Name-Authentication"><a href="#7-2-Tls-Name-Authentication" class="headerlink" title="7.2. Tls Name Authentication"></a>7.2. Tls Name Authentication</h2><p>SHOULD<br>[RFC7673]<br>[RFC6066]<br>[RFC8310]<br>As described in Section 6.1, the client discovers the DNS Push Notification server using an SRV lookup for the record name _dns‑push‑tls._tcp.<zone>. The server connection endpoint then be authenticated using DANE TLSA records for the associated SRV record. This associates the target’s name and port number with a trusted TLS certificate<br>. This procedure uses the TLS Server Name Indication (SNI) extension to inform the server of the name the client has authenticated through the use of TLSA records. Therefore, if the SRV record passes DNSSEC validation and a TLSA record matching the target name is usable, an SNI extension must be used for the target name to ensure the client is connecting to the server it has authenticated. If the target name does not have a usable TLSA record, then the use of the SNI extension is optional. See Usage Profiles for DNS over TLS and DNS over DTLS<br> for more information on authenticating domain names.</p>
<h2 id="7-3-Tls-Early-Data"><a href="#7-3-Tls-Early-Data" class="headerlink" title="7.3. Tls Early Data"></a>7.3. Tls Early Data</h2><p>DSO messages with the SUBSCRIBE TLV as the Primary TLV are permitted in TLS early data.</p>
<p>Using TLS early data can save one network round trip and can result in the client obtaining results faster. However, there are some factors to consider before using TLS early data. TLS early data is not forward secret. In cases where forward secrecy of DNS Push Notification subscriptions is required, the client should not use TLS early data.</p>
<p>MAY<br>With TLS early data, there are no guarantees of non-replay between connections. If packets are duplicated and delayed in the network, the later arrivals could be mistaken for new subscription requests. Generally, this is not a major concern since the amount of state generated on the server for these spurious subscriptions is small and short lived since the TCP connection will not complete the three-way handshake. Servers choose to implement rate-limiting measures that are activated when the server detects an excessive number of spurious subscription requests. For further guidance on use of TLS early data, please see discussion of zero round-trip data in Sections 2.3 and 8, and Appendix E.5, of<br>.</p>
<p>the TLS 1.3 specification [RFC8446]</p>
<h2 id="7-4-Tls-Session-Resumption"><a href="#7-4-Tls-Session-Resumption" class="headerlink" title="7.4. Tls Session Resumption"></a>7.4. Tls Session Resumption</h2><p>[RFC8446]<br>TLS session resumption is permissible on DNS Push Notification servers. However, closing the TLS connection terminates the DSO session. When the TLS session is resumed, the DNS Push Notification server will not have any subscription state and will proceed as with any other new DSO session. Use of TLS session resumption may allow a TLS connection to be set up more quickly, but the client will still have to recreate any desired subscriptions.</p>
<h2 id="8-Iana-Considerations"><a href="#8-Iana-Considerations" class="headerlink" title="8. Iana Considerations"></a>8. Iana Considerations</h2><p>This document defines a new service name, only applicable for the TCP protocol, which has been recorded in the IANA “Service Name and Transport Protocol Port Number Registry” </p>
<p>.</p>
<p>[RFC6335]<br>[SRVTYPE]</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Port</th>
<th>Value</th>
<th>Section</th>
</tr>
</thead>
<tbody><tr>
<td>DNS Push Noti</td>
<td>fi</td>
<td>cation Service Type</td>
<td>None</td>
</tr>
<tr>
<td>_dns</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>‑</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>push</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>‑</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>tls._tcp</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>6.1</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>This document defines four new DNS Stateful Operation TLV types, which have been recorded in the IANA “DSO Type Codes” registry </p>
<p>.</p>
<p>[RFC8490] [DSOTYPE]</p>
<table>
<thead>
<tr>
<th></th>
<th>Name</th>
<th>Value</th>
<th>Early Data</th>
<th>Status</th>
<th>Section</th>
</tr>
</thead>
<tbody><tr>
<td>SUBSCRIBE</td>
<td>0x0040</td>
<td>OK</td>
<td>Standards Track</td>
<td>6.2</td>
<td></td>
</tr>
<tr>
<td>PUSH</td>
<td>0x0041</td>
<td>NO</td>
<td>Standards Track</td>
<td>6.3</td>
<td></td>
</tr>
<tr>
<td>UNSUBSCRIBE</td>
<td>0x0042</td>
<td>NO</td>
<td>Standards Track</td>
<td>6.4</td>
<td></td>
</tr>
<tr>
<td>RECONFIRM</td>
<td>0x0043</td>
<td>NO</td>
<td>Standards Track</td>
<td>6.5</td>
<td></td>
</tr>
</tbody></table>
<p>This document defines no new DNS OPCODEs or RCODEs.</p>
<h2 id="9-References-9-1-Normative-References"><a href="#9-References-9-1-Normative-References" class="headerlink" title="9. References 9.1. Normative References"></a>9. References 9.1. Normative References</h2><table>
<thead>
<tr>
<th>[DSOTYPE]</th>
<th>IANA “Domain Name System (DNS) Parameters” &lt;</th>
</tr>
</thead>
<tbody><tr>
<td>assignments/dns-parameters/</td>
<td>&gt;</td>
</tr>
<tr>
<td>,</td>
<td>,</td>
</tr>
<tr>
<td>.</td>
<td></td>
</tr>
<tr>
<td>[RFC0020]</td>
<td></td>
</tr>
</tbody></table>
<p>Cerf, V. “ASCII format for network interchange” STD 80 RFC 20 DOI 10.17487/ RFC0020<br><a target="_blank" rel="noopener" href="https://www.rfc-editor.org/info/rfc20">https://www.rfc-editor.org/info/rfc20</a><br>,<br>,<br>,<br>,<br>, October 1969,<br>. </p>
<p>[RFC0768]</p>
<p>Postel, J. “User Datagram Protocol” STD 6 RFC 768 DOI 10.17487/RFC0768<br><a target="_blank" rel="noopener" href="https://www.rfc-editor.org/info/rfc768">https://www.rfc-editor.org/info/rfc768</a><br>,<br>,<br>,<br>,<br>,<br>August 1980,<br>.<br>[RFC0793]<br>Postel, J. “Transmission Control Protocol” STD 7 RFC 793 DOI 10.17487/ RFC0793<br><a target="_blank" rel="noopener" href="https://www.rfc-editor.org/info/rfc793">https://www.rfc-editor.org/info/rfc793</a><br>,<br>,<br>,<br>,<br>, September 1981,<br>.<br>[RFC1034]<br>Mockapetris, P. “Domain names - concepts and facilities” STD 13 RFC 1034 DOI 10.17487/RFC1034<br><a target="_blank" rel="noopener" href="https://www.rfc-editor.org/info/rfc1034">https://www.rfc-editor.org/info/rfc1034</a><br>,<br>,<br>,<br>,<br>, November 1987,<br>.<br>[RFC1035]<br>Mockapetris, P. “Domain names - implementation and specification” STD 13 RFC 1035 DOI 10.17487/RFC1035<br>&lt;<a target="_blank" rel="noopener" href="https://www.rfc-editor.org/">https://www.rfc-editor.org/</a><br>info/rfc1035&gt;<br>,<br>,<br>,<br>,<br>, November 1987,<br>.<br>[RFC1123]<br>Braden, R., Ed. “Requirements for Internet Hosts - Application and Support” STD 3 RFC 1123 DOI 10.17487/RFC1123<br><a target="_blank" rel="noopener" href="https://www.rfceditor.org/info/rfc1123">https://www.rfceditor.org/info/rfc1123</a><br>,<br>,<br>,<br>,<br>, October 1989,<br>.<br>[RFC2119]<br>Bradner, S. “Key words for use in RFCs to Indicate Requirement Levels” BCP 14 RFC 2119 DOI 10.17487/RFC2119<br>&lt;<a target="_blank" rel="noopener" href="https://www.rfc-editor.org/info/">https://www.rfc-editor.org/info/</a><br>rfc2119&gt;<br>,<br>,<br>,<br>,<br>, March 1997,<br>.<br>[RFC2136]<br>Vixie, P., Ed., Thomson, S., Rekhter, Y., and J. Bound “Dynamic Updates in the Domain Name System (DNS UPDATE)” RFC 2136 DOI 10.17487/RFC2136<br><a target="_blank" rel="noopener" href="https://www.rfc-editor.org/info/rfc2136">https://www.rfc-editor.org/info/rfc2136</a><br>,<br>,<br>,<br>, April<br>1997,<br>.<br>[RFC2181]<br>Elz, R. and R. Bush “Clarifications to the DNS Specification” RFC 2181 DOI 10.17487/RFC2181<br><a target="_blank" rel="noopener" href="https://www.rfc-editor.org/info/rfc2181">https://www.rfc-editor.org/info/rfc2181</a><br>,<br>,<br>,<br>, July 1997,<br>.<br>[RFC2782]<br>Gulbrandsen, A., Vixie, P., and L. Esibov “A DNS RR for specifying the location of<br>services (DNS SRV)” RFC 2782 DOI 10.17487/RFC2782<br>&lt;https://<br><a target="_blank" rel="noopener" href="http://www.rfc-editor.org/info/rfc2782&gt;">www.rfc-editor.org/info/rfc2782&gt;</a><br>,<br>,<br>,<br>, February 2000,<br>.<br>[RFC6066]<br>Eastlake 3rd, D. “Transport Layer Security (TLS) Extensions: Extension Definitions” RFC 6066 DOI 10.17487/RFC6066<br><a target="_blank" rel="noopener" href="https://www.rfceditor.org/info/rfc6066">https://www.rfceditor.org/info/rfc6066</a><br>,<br>,<br>,<br>, January 2011,<br>.<br>[RFC6335]<br>,<br>Cotton, M., Eggert, L., Touch, J., Westerlund, M., and S. Cheshire “Internet Assigned Numbers Authority (IANA) Procedures for the Management of the Service Name and Transport Protocol Port Number Registry” BCP 165 RFC 6335 DOI 10.17487/RFC6335<br><a target="_blank" rel="noopener" href="https://www.rfc-editor.org/info/rfc6335">https://www.rfc-editor.org/info/rfc6335</a><br>,<br>,<br>,<br>, August 2011,<br>.<br>[RFC6895]<br>Eastlake 3rd, D. “Domain Name System (DNS) IANA Considerations” BCP 42 RFC 6895 DOI 10.17487/RFC6895<br>&lt;<a target="_blank" rel="noopener" href="https://www.rfc-editor.org/info/">https://www.rfc-editor.org/info/</a><br>rfc6895&gt;<br>,<br>,<br>,<br>,<br>, April 2013,<br>.<br>[RFC7673]<br>Finch, T., Miller, M., and P. Saint-Andre “Using DNS-Based Authentication of Named Entities (DANE) TLSA Records with SRV Records” RFC 7673 DOI 10.17487/RFC7673<br><a target="_blank" rel="noopener" href="https://www.rfc-editor.org/info/rfc7673">https://www.rfc-editor.org/info/rfc7673</a><br>,<br>,<br>,<br>, October 2015,<br>.<br>[RFC7766]<br>,<br>,<br>,<br>,<br>March 2016,<br>.<br>Dickinson, J., Dickinson, S., Bellis, R., Mankin, A., and D. Wessels “DNS Transport over TCP - Implementation Requirements” RFC 7766 DOI 10.17487/RFC7766<br><a target="_blank" rel="noopener" href="https://www.rfc-editor.org/info/rfc7766">https://www.rfc-editor.org/info/rfc7766</a><br>[RFC7858]<br>Hu, Z., Zhu, L., Heidemann, J., Mankin, A., Wessels, D., and P. Hoffman “Specification for DNS over Transport Layer Security (TLS)” RFC 7858 DOI 10.17487/RFC7858<br><a target="_blank" rel="noopener" href="https://www.rfc-editor.org/info/rfc7858">https://www.rfc-editor.org/info/rfc7858</a><br>,<br>,<br>,<br>, May 2016,<br>.<br>[RFC8174]<br>Leiba, B. “Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words” BCP 14 RFC 8174 DOI 10.17487/RFC8174<br>&lt;<a target="_blank" rel="noopener" href="https://www.rfc-editor.org/info/">https://www.rfc-editor.org/info/</a><br>rfc8174&gt;<br>,<br>,<br>,<br>,<br>, May 2017,<br>.<br>[RFC8310]<br>Dickinson, S., Gillmor, D., and T. Reddy “Usage Profiles for DNS over TLS and DNS over DTLS” RFC 8310 DOI 10.17487/RFC8310<br>&lt;https://<br><a target="_blank" rel="noopener" href="http://www.rfc-editor.org/info/rfc8310&gt;">www.rfc-editor.org/info/rfc8310&gt;</a><br>,<br>,<br>,<br>, March 2018,<br>.<br>[RFC8446]<br>Rescorla, E. “The Transport Layer Security (TLS) Protocol Version 1.3” RFC 8446 DOI 10.17487/RFC8446<br><a target="_blank" rel="noopener" href="https://www.rfc-editor.org/info/rfc8446">https://www.rfc-editor.org/info/rfc8446</a><br>,<br>,<br>,<br>, August 2018,<br>.<br>[RFC8490]<br>Bellis, R., Cheshire, S., Dickinson, J., Dickinson, S., Lemon, T., and T. Pusateri “DNS Stateful Operations” RFC 8490 DOI 10.17487/RFC8490 <a target="_blank" rel="noopener" href="https://www.rfc-editor.org/info/rfc8490">https://www.rfc-editor.org/info/rfc8490</a><br>,<br>,<br>,<br>, March 2019,<br>.<br>[SRVTYPE]<br>IANA “Service Name and Transport Protocol Port Number Registry” &lt;https:// <a target="_blank" rel="noopener" href="http://www.iana.org/assignments/service-names-port-numbers/&gt;">www.iana.org/assignments/service-names-port-numbers/&gt;</a><br>,<br>,<br>. </p>
<h2 id="9-2-Informative-References"><a href="#9-2-Informative-References" class="headerlink" title="9.2. Informative References"></a>9.2. Informative References</h2><p>[BCP195]<br>Sheffer, Y., Holz, R., and P. Saint-Andre “Recommendations for Secure Use of<br>Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)”<br>BCP 195 RFC 7525<br><a target="_blank" rel="noopener" href="https://www.rfc-editor.org/info/bcp195">https://www.rfc-editor.org/info/bcp195</a><br>,<br>,<br>,<br>, May 2015,<br>.<br>[OBS]<br>Wikipedia “Observer pattern”<br>&lt;<a target="_blank" rel="noopener" href="https://en.wikipedia.org/w/">https://en.wikipedia.org/w/</a><br>index.php?title=Observer_pattern&amp;oldid=939702131&gt;<br>,<br>, February 2020,<br>.<br>[RFC2308]<br>Andrews, M. “Negative Caching of DNS Queries (DNS NCACHE)” RFC 2308 DOI 10.17487/RFC2308<br><a target="_blank" rel="noopener" href="https://www.rfc-editor.org/info/rfc2308">https://www.rfc-editor.org/info/rfc2308</a><br>,<br>,<br>,<br>, March 1998,<br>.<br>[RFC3123]<br>Koch, P. “A DNS RR Type for Lists of Address Prefixes (APL RR)” RFC 3123 DOI 10.17487/RFC3123<br><a target="_blank" rel="noopener" href="https://www.rfc-editor.org/info/rfc3123">https://www.rfc-editor.org/info/rfc3123</a><br>,<br>,<br>,<br>, June 2001,<br>.<br>[RFC4287]<br>Nottingham, M., Ed. and R. Sayre, Ed. “The Atom Syndication Format” RFC 4287 DOI 10.17487/RFC4287<br>&lt;<a target="_blank" rel="noopener" href="https://www.rfc-editor.org/info/">https://www.rfc-editor.org/info/</a><br>rfc4287&gt;<br>,<br>,<br>,<br>, December 2005,<br>.<br>[RFC4953]<br>Touch, J. “Defending TCP Against Spoofing Attacks” RFC 4953 DOI 10.17487/ RFC4953<br><a target="_blank" rel="noopener" href="https://www.rfc-editor.org/info/rfc4953">https://www.rfc-editor.org/info/rfc4953</a><br>,<br>,<br>,<br>, July 2007,<br>.<br>[RFC6281]<br>Cheshire, S., Zhu, Z., Wakikawa, R., and L. Zhang “Understanding Apple’s Back to My Mac (BTMM) Service” RFC 6281 DOI 10.17487/RFC6281<br>&lt;https://<br><a target="_blank" rel="noopener" href="http://www.rfc-editor.org/info/rfc6281&gt;">www.rfc-editor.org/info/rfc6281&gt;</a><br>,<br>,<br>,<br>, June 2011,<br>.<br>[RFC6762]<br>,<br>,<br>,<br>,<br>February 2013,<br>.<br>Cheshire, S. and M. Krochmal “Multicast DNS” RFC 6762 DOI 10.17487/RFC6762<br><a target="_blank" rel="noopener" href="https://www.rfc-editor.org/info/rfc6762">https://www.rfc-editor.org/info/rfc6762</a><br>[RFC6763]<br>Cheshire, S. and M. Krochmal “DNS-Based Service Discovery” RFC 6763 DOI 10.17487/RFC6763<br><a target="_blank" rel="noopener" href="https://www.rfc-editor.org/info/rfc6763">https://www.rfc-editor.org/info/rfc6763</a><br>,<br>,<br>,<br>, February 2013,<br>.<br>[RFC6886]<br>Cheshire, S. and M. Krochmal “NAT Port Mapping Protocol (NAT-PMP)” RFC 6886 DOI 10.17487/RFC6886<br>&lt;<a target="_blank" rel="noopener" href="https://www.rfc-editor.org/info/">https://www.rfc-editor.org/info/</a><br>rfc6886&gt;<br>,<br>,<br>,<br>, April 2013,<br>.<br>[RFC6887]<br>Wing, D., Ed., Cheshire, S., Boucadair, M., Penno, R., and P. Selkirk “Port Control Protocol (PCP)” RFC 6887 DOI 10.17487/RFC6887<br><a target="_blank" rel="noopener" href="https://www.rfceditor.org/info/rfc6887">https://www.rfceditor.org/info/rfc6887</a><br>,<br>,<br>,<br>, April 2013,<br>.<br>[RFC7413]<br>Cheng, Y., Chu, J., Radhakrishnan, S., and A. Jain “TCP Fast Open” RFC 7413 DOI 10.17487/RFC7413<br><a target="_blank" rel="noopener" href="https://www.rfc-editor.org/info/rfc7413">https://www.rfc-editor.org/info/rfc7413</a><br>,<br>,<br>,<br>, December 2014,<br>.<br>[RFC8010]<br>Sweet, M. and I. McDonald “Internet Printing Protocol/1.1: Encoding and Transport” STD 92 RFC 8010 DOI 10.17487/RFC8010<br>&lt;https://<br><a target="_blank" rel="noopener" href="http://www.rfc-editor.org/info/rfc8010&gt;">www.rfc-editor.org/info/rfc8010&gt;</a><br>,<br>,<br>,<br>,<br>, January 2017,<br>.<br>[RFC8011]<br>Sweet, M. and I. McDonald “Internet Printing Protocol/1.1: Model and Semantics” STD 92 RFC 8011 DOI 10.17487/RFC8011<br>&lt;https://<br><a target="_blank" rel="noopener" href="http://www.rfc-editor.org/info/rfc8011&gt;">www.rfc-editor.org/info/rfc8011&gt;</a><br>,<br>,<br>,<br>,<br>, January 2017,<br>.<br>[RFC8499]<br>,<br>,<br>,<br>,<br>, January 2019,<br>.<br>Hoffman, P., Sullivan, A., and K. Fujiwara “DNS Terminology” BCP 219 RFC 8499 DOI 10.17487/RFC8499<br>&lt;<a target="_blank" rel="noopener" href="https://www.rfc-editor.org/info/">https://www.rfc-editor.org/info/</a><br>rfc8499&gt;<br>[RFC8684]<br>,<br>,<br>,<br>, March 2020,<br>.<br>Ford, A., Raiciu, C., Handley, M., Bonaventure, O., and C. Paasch “TCP Extensions<br>for Multipath Operation with Multiple Addresses” RFC 8684 DOI 10.17487/ RFC8684<br><a target="_blank" rel="noopener" href="https://www.rfc-editor.org/info/rfc8684">https://www.rfc-editor.org/info/rfc8684</a><br>[RFC8764]<br>,<br>,<br>,<br>, June 2020,<br>.<br>Cheshire, S. and M. Krochmal “Apple’s DNS Long-Lived Queries Protocol” RFC 8764 DOI 10.17487/RFC8764<br>&lt;<a target="_blank" rel="noopener" href="https://www.rfc-editor.org/info/">https://www.rfc-editor.org/info/</a><br>rfc8764&gt;<br>[RFC8766]<br>Cheshire, S. “Discovery Proxy for Multicast DNS-Based Service Discovery” RFC 8766 DOI 10.17487/RFC8766<br>&lt;<a target="_blank" rel="noopener" href="https://www.rfc-editor.org/info/">https://www.rfc-editor.org/info/</a><br>rfc8766&gt;<br>,<br>,<br>,<br>, June 2020,<br>.<br>[SD-API]<br>Apple Inc. “dns_sd.h” &lt;<a target="_blank" rel="noopener" href="https://opensource.apple.com/source/mDNSResponder/">https://opensource.apple.com/source/mDNSResponder/</a> mDNSResponder-878.70.2/mDNSShared/dns_sd.h.auto.html&gt;<br>,<br>,<br>.<br>[SYN]<br>Eddy, W. “Defenses Against TCP SYN Flooding Attacks” The Internet Protocol Journal Cisco Systems Volume 9 Number 4<br>&lt;https://<br><a target="_blank" rel="noopener" href="http://www.cisco.com/web/about/ac123/ac147/archived_issues/ipj_9-4/ipj_9-4.pdf&gt;">www.cisco.com/web/about/ac123/ac147/archived_issues/ipj_9-4/ipj_9-4.pdf&gt;</a><br>,<br>,<br>,<br>,<br>,<br>, December 2006,<br>.<br>[TCPRACK]<br>Cheng, Y., Cardwell, N., Dukkipati, N., and P. Jha “RACK: a time-based fast loss detection algorithm for TCP” Work in Progress Internet-Draft, draft-ietf-tcpmrack-08<br><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/draft-ietf-tcpm-rack-08">https://tools.ietf.org/html/draft-ietf-tcpm-rack-08</a><br>,<br>,<br>,<br>, 9 March 2020,<br>.<br>[XEP0060]<br>Millard, P., Saint-Andre, P., and R. Meijer “Publish-Subscribe” XSF XEP 0060<br><a target="_blank" rel="noopener" href="https://xmpp.org/extensions/xep-0060.html">https://xmpp.org/extensions/xep-0060.html</a><br>,<br>,<br>,<br>October 2019,<br>. </p>
<h2 id="Acknowledgments"><a href="#Acknowledgments" class="headerlink" title="Acknowledgments"></a>Acknowledgments</h2><p>Kiren Sekar Marc Krochmal The authors would like to thank and for previous work completed in this field. This document has been improved due to comments from<br>,<br>,<br>,<br>,<br>,<br>,<br>,<br>,<br>,<br>,<br>,<br>,<br>,<br>,<br>,<br>,<br>,<br>,<br>,<br>, and<br>. </p>
<p> provided clarifying text that was greatly appreciated.</p>
<p>Ran Atkinson Tim Chown Sara Dickinson Mark Delany Ralph Droms Jan Komissar Eric Rescorla Michael Richardson David Schinazi Manju Shankar Rao Robert Sparks Markus Stenberg Andrew Sullivan Michael Sweet Dave Thaler Brian Trammell Bernie Volz Éric Vyncke Christopher Wood Liang Xia Soraia Zlatkovic Ted Lemon</p>
<h2 id="Authors’-Addresses"><a href="#Authors’-Addresses" class="headerlink" title="Authors’ Addresses"></a>Authors’ Addresses</h2><p>Tom Pusateri Unaffiliated<br>, </p>
<p>Raleigh NC 27608<br>United States of America Phone: +1 919 867 1330<br> <a href="mailto:&#x70;&#117;&#x73;&#x61;&#x74;&#101;&#x72;&#105;&#x40;&#98;&#x61;&#110;&#103;&#106;&#x2e;&#99;&#x6f;&#109;">&#x70;&#117;&#x73;&#x61;&#x74;&#101;&#x72;&#105;&#x40;&#98;&#x61;&#110;&#103;&#106;&#x2e;&#99;&#x6f;&#109;</a> Email: Stuart Cheshire Apple Inc. One Apple Park Way<br>, </p>
<p>Cupertino CA 95014<br>United States of America Phone: +1 (408) 996-1010<br> <a href="mailto:&#99;&#x68;&#101;&#x73;&#104;&#105;&#114;&#x65;&#x40;&#x61;&#x70;&#112;&#108;&#101;&#x2e;&#x63;&#111;&#109;">&#99;&#x68;&#101;&#x73;&#104;&#105;&#114;&#x65;&#x40;&#x61;&#x70;&#112;&#108;&#101;&#x2e;&#x63;&#111;&#109;</a> Email:</p>

    </div>

    
    
    <div class="post-widgets">
      <div id="needsharebutton-postbottom">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    </div>

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/12/11/2023/rfc8765/rfc8765/" rel="prev" title="">
      <i class="fa fa-chevron-left"></i> 
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/12/11/2023/rfc8799/" rel="next" title="">
       <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Rfc-8765-Dns-Push-Notifications-Abstract"><span class="nav-number">1.</span> <span class="nav-text">Rfc 8765 Dns Push Notifications Abstract</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Status-Of-This-Memo"><span class="nav-number">2.</span> <span class="nav-text">Status Of This Memo</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Copyright-Notice"><span class="nav-number">3.</span> <span class="nav-text">Copyright Notice</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Table-Of-Contents"><span class="nav-number">4.</span> <span class="nav-text">Table Of Contents</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Introduction"><span class="nav-number">5.</span> <span class="nav-text">1. Introduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-Requirements-Language"><span class="nav-number">6.</span> <span class="nav-text">1.1. Requirements Language</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-Fatal-Errors"><span class="nav-number">7.</span> <span class="nav-text">1.2. Fatal Errors</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Motivation"><span class="nav-number">8.</span> <span class="nav-text">2. Motivation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Overview"><span class="nav-number">9.</span> <span class="nav-text">3. Overview</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-State-Considerations"><span class="nav-number">10.</span> <span class="nav-text">4. State Considerations</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Transport"><span class="nav-number">11.</span> <span class="nav-text">5. Transport</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Required"><span class="nav-number">12.</span> <span class="nav-text">Required</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-Protocol-Operation"><span class="nav-number">13.</span> <span class="nav-text">6. Protocol Operation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-Discovery"><span class="nav-number">14.</span> <span class="nav-text">6.1. Discovery</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-Dns-Push-Notification-Subscribe"><span class="nav-number">15.</span> <span class="nav-text">6.2. Dns Push Notification Subscribe</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-1-Subscribe-Request"><span class="nav-number">16.</span> <span class="nav-text">6.2.1. Subscribe Request</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Dso-Type-Is-Subscribe-0X0040"><span class="nav-number">17.</span> <span class="nav-text">The Dso-Type Is Subscribe (0X0040).</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-2-Subscribe-Response"><span class="nav-number">18.</span> <span class="nav-text">6.2.2. Subscribe Response</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#May"><span class="nav-number">19.</span> <span class="nav-text">May</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-Dns-Push-Notification-Updates"><span class="nav-number">20.</span> <span class="nav-text">6.3. Dns Push Notification Updates</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-1-Push-Message"><span class="nav-number">21.</span> <span class="nav-text">6.3.1. Push Message</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Should-Should"><span class="nav-number">22.</span> <span class="nav-text">Should Should</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ns-Cname-Ptr-Dname-Soa-Mx-Afsdb-Rt-Kx-Rp-Px-Srv-Nsec-Must-Not-Must"><span class="nav-number">23.</span> <span class="nav-text">Ns, Cname, Ptr, Dname, Soa, Mx, Afsdb, Rt, Kx, Rp, Px, Srv, Nsec Must Not Must</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-Dns-Push-Notification-Unsubscribe"><span class="nav-number">24.</span> <span class="nav-text">6.4. Dns Push Notification Unsubscribe</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-1-Unsubscribe-Message"><span class="nav-number">25.</span> <span class="nav-text">6.4.1. Unsubscribe Message</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-5-Dns-Push-Notification-Reconfirm"><span class="nav-number">26.</span> <span class="nav-text">6.5. Dns Push Notification Reconfirm</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-5-1-Reconfirm-Message"><span class="nav-number">27.</span> <span class="nav-text">6.5.1. Reconfirm Message</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-6-Dns-Stateful-Operations-Tlv-Context-Summary"><span class="nav-number">28.</span> <span class="nav-text">6.6. Dns Stateful Operations Tlv Context Summary</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-7-Client-Initiated-Termination"><span class="nav-number">29.</span> <span class="nav-text">6.7. Client-Initiated Termination</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-8-Client-Fallback-To-Polling"><span class="nav-number">30.</span> <span class="nav-text">6.8. Client Fallback To Polling</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-Security-Considerations"><span class="nav-number">31.</span> <span class="nav-text">7. Security Considerations</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-Security-Services"><span class="nav-number">32.</span> <span class="nav-text">7.1. Security Services</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-Tls-Name-Authentication"><span class="nav-number">33.</span> <span class="nav-text">7.2. Tls Name Authentication</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-Tls-Early-Data"><span class="nav-number">34.</span> <span class="nav-text">7.3. Tls Early Data</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-Tls-Session-Resumption"><span class="nav-number">35.</span> <span class="nav-text">7.4. Tls Session Resumption</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-Iana-Considerations"><span class="nav-number">36.</span> <span class="nav-text">8. Iana Considerations</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-References-9-1-Normative-References"><span class="nav-number">37.</span> <span class="nav-text">9. References 9.1. Normative References</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-2-Informative-References"><span class="nav-number">38.</span> <span class="nav-text">9.2. Informative References</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Acknowledgments"><span class="nav-number">39.</span> <span class="nav-text">Acknowledgments</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Authors%E2%80%99-Addresses"><span class="nav-number">40.</span> <span class="nav-text">Authors’ Addresses</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">jason</p>
  <div class="site-description" itemprop="description">唯有读书最快乐</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jason</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script>
  <script>
      pbOptions = {};
        pbOptions.iconStyle = "box";
        pbOptions.boxForm = "horizontal";
        pbOptions.position = "bottomCenter";
        pbOptions.networks = "Wechat,QQZone,Weibo,Douban,Twitter,Facebook";
      new needShareButton('#needsharebutton-postbottom', pbOptions);
  </script>
</body>
</html>
